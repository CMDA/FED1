<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Display None — Hoorcollege 4 — Front-end development V1</title>

		<meta name="description" content="Hoorcollege bij les 4 van Frontend Development in de V1 op de HvA.">
		<meta name="author" content="Vasilis van Gemert">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
	<script src="prefixfree/prefixfree.min.js"></script>
		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>
		<style>
		.reveal video {
			max-height: 90vh;
		}
textarea,
iframe {
	height: 50vh;
	width: 100%;
	font-size: 1.2em;
	background: hsl(210, 13%, 50%);
	color: white;
	text-shadow: 0.05em 0.05em 0.1em hsla(0, 0%, 0%, 0.3);
}
iframe {
	height: 80vh;
}
.reveal section img[src$=".svg"] {
	background: white;
}
		</style>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Display None</h1>
					<h3>Frontend Development Les 4</h3>
				</section>

				<section>
					<h1>Vorige week</h1>
					<ul>
						<li>Box Model</li>
						<li>Positioning</li>
						<li>Units</li>
					</ul>
					<aside class="notes">
						Even heel kort samenvatten waar we het ook al weer over hebben gehad vorige week. Niet te lang bij stilstaan want er is heel veel materiaal te behandelen.
					</aside>
				</section>

				<!-- Example of nested vertical slides -->

				<!-- <section>
					<section>
						<h2>Selectors</h2>
						<p>Deel 2</p>
						
						<aside class="notes">
							We gaan verder in op selectors. Even nog de nth-child en nth-of-type selectors bespreken en dan vooral bekijken wat we er allemaal mee kunnen doen.
						</aside>
					</section>
					<section>
						<h2>Rechts naar links</h2>
						<pre><code data-trim contenteditable>
body > div {
	color: green;
}
h1 + p {
	margin-top: -1em;
}
h1, p {
	font-weight: normal;
}</pre></code>
						<aside class="notes">
							De makkelijkste manier om een selector te lezen is om van rechts naar links te lezen: een div die direct in de body staat. Een p die direct na een h1 staat. Die derde staat er bij omdat mensen soms denken dat de + hetzelfde is als de komma.
						</aside>
					</section>
					<section>
						<h2>child selectors</h2>
						<pre><code data-trim contenteditable>
p:first-child {
	font-size: 1.414em;
}</code></pre>
						<aside class="notes">
							De meeste studenten kunnen wel verzinnen wat dit betekent
						</aside>
					</section>
					<section>
						<h2>child selectors</h2>
						<pre><code data-trim contenteditable>
p:first-child {
	font-size: 1.414em;
}</code></pre>
<pre><code data-trim contenteditable>
p:first-of-type {
	font-size: 1.414em;
}</code></pre>
						<aside class="notes">
							Vraag ze naar het verschil tussen deze twee. De eerste is alleen voor paragrafen die daadwerkelijk de eerste child zijn van hun parent. De tweede is voor elke eerste paragraaf in een parent, ook als er bijvoorbeeld een h1 voor staat. Of 100 ul's.
						</aside>
					</section>
					<section>
						<h2>child selectors</h2>
						<pre><code data-trim contenteditable>
li:nth-of-type(2) {
	background: papayawhip;
}</code></pre>
<pre><code data-trim contenteditable>
li:nth-of-type(2n) {
	background: papayawhip;
}</code></pre>
						<aside class="notes">
							Zebrastriping doe je zo
						</aside>
					</section>
					<section>
						<h2>child selectors</h2>
<pre><code data-trim contenteditable>
li {
	background: rebeccapurple;
}
li:nth-of-type(3n + 2) {
	background: papayawhip;
}
li:nth-of-type(3n + 3) {
	background: olivedrab;
}</code></pre>
						<aside class="notes">
							Clownstriping — met drie kleuren — doe je zo. Laat zien dat het makkelijk is als je rechts begint met lezen: Selecteer de derde, neem vervolgens telkens een stap van drie.
						</aside>
					</section>
					<section>
						<h2>De laatste drie selecteren</h2>
<pre class="fragment"><code data-trim contenteditable>
div:nth-last-of-type(-n + 3) {
	width: 33.33333%;
}
</code></pre>			
						<aside class="notes">
							Begin op de derde vanaf en eind, en tel er dan telkens -1 bij op (is hetzelfde als trek er telkens 1 van af ja).
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>JavaScript!</h2>
						<aside class="notes">
							Deze selectors kunnen we ook in JavaScript gebruiken, om een class te togglen op een element.
						</aside>
					</section>
					<section>
						<h2>querySelector</h2>
<pre><code data-trim contenteditable>
var nextStep = document.querySelector('fieldset:nth-of-type(2n)');</code></pre>
						<aside class="notes">
							querySelector selecteert de eerst instance van een selector. In dit geval de tweede fieldset, ook als het er zes zijn
						</aside>
					</section>
					<section>
						<h2>querySelectorAll</h2>
<pre><code data-trim contenteditable>
var secondSteps = document.querySelectorAll('fieldset:nth-of-type(2n)');</code></pre>
						<aside class="notes">
							querySelectorAll maakt een nodelist van elke tweede fieldset. Als er zes fieldsets zijn dan zijn er drie items in deze nodelist. secondSteps[1] zou de tweede daarvan aanspreken.
						</aside>
					</section>
					<section>
						<h2>classList</h2>
<pre><code data-trim contenteditable>
var nextStep = document.querySelector('fieldset:nth-of-type(2n)');
nextStep.classList.add('is-visible');</code></pre>
						<aside class="notes">
							querySelector selecteert de eerst instance van een selector. In dit geval de tweede fieldset, ook als het er zes zijn
						</aside>
					</section>
					<section>
						<h2>classList</h2>
<pre><code data-trim contenteditable>
var nextStep = document.querySelector('fieldset:nth-of-type(2n)');
nextStep.classList.add('is-visible');</code></pre>
					<p><a href="examples/fieldsets.html">voorbeeld</a></p>
						<aside class="notes">
							Met classList kan je heel makkelijk classes toevoegen, verwijderen of togglen
						</aside>
					</section>
					<section>
						<h2>classList</h2>
<pre><code data-trim contenteditable>
nextStep.classList.add('is-visible');</code></pre>
<pre><code data-trim contenteditable>
nextStep.classList.remove('is-visible');</code></pre>
<pre><code data-trim contenteditable>
nextStep.classList.toggle('is-visible');</code></pre>
					
						<aside class="notes">
							querySelector selecteert de eerst instance van een selector. In dit geval de tweede fieldset, ook als het er zes zijn
						</aside>
					</section>
				</section> -->
				
				<section>
					<section>
						<h1>Flexbox</h1>
						<p>Dingen naast elkaar op een lijn zetten</p>
						<p><a href="http://css-tricks.com/snippets/css/a-guide-to-flexbox/">Zie hier</a></p>
						
						<aside class="notes">
							CSS was voor teksten. We misbruikten proprties om layouts te kunnen maken. Er was behoefte aan krachtigere tools om mee te layouten. Een daarvan is Flexbox.
							Het idee achter flexbox is dat je het parent-element de mogelijkheid om de beschikbare ruimte zo goed mogelijk te verdelen onder de children. 
							Lees deze pagina goed door. Dat is voor een groot deel onze les: http://css-tricks.com/snippets/css/a-guide-to-flexbox/
							Bekijk ook deze pagina, want daar staan hele goed voorbeelden: http://philipwalton.github.io/solved-by-flexbox/
						</aside>
					</section>
					<section>
						<h2>Properties for the parent</h2>
						<img src="img/flex-container.svg" alt="">
<pre><code data-trim contenteditable>
.container {
  display: flex;
}</code></pre>
						<aside class="notes">
							Zo maak je een container een flexbox. 
						</aside>
					</section>
					<section>
						<h2>Properties for the parent</h2>
						<p>flex-direction</p>
						<img src="img/flex-direction1.svg" alt="">
<pre><code data-trim contenteditable>
.container {
  flex-direction: row | row-reverse | column | column-reverse;
}</code></pre>
						<aside class="notes">
							Je kan de content vier richtingen meegeven
						</aside>
					</section>
					<section>
						<h2>Properties for the parent</h2>
						<p>justify-content</p>
						<img src="img/justify-content.svg" alt="">
<pre><code class="css" data-trim contenteditable>
.container {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}</code></pre>
						<aside class="notes">
							Uitlijning kan op een aantal manieren. Lekker flexibel!
						</aside>
					</section>
					<section>
						<h2>Properties for the parent</h2>
						<p>align-items</p>
						<img src="img/align-items.svg" alt="">
<pre><code data-trim contenteditable>
.container {
  align-items: flex-start | flex-end | center | baseline | stretch;
}</code></pre>
						<aside class="notes">
							Uitlijning kan op een aantal manieren. Lekker flexibel!
						</aside>
					</section>
					<section>
						<h2>Properties for the parent</h2>
						<p>flex-wrap</p>
						<img src="img/flex-wrap.svg" alt="">
<pre><code data-trim contenteditable>
.container {
	flex-wrap: nowrap | wrap | wrap-reverse;
}</code></pre>
						<aside class="notes">
							Je kan ook over meerdere regels flexen. Zonder deze property zal alles op een regel gepropt worden
						</aside>
					</section>
					<section>
						<h2>Properties for the parent</h2>
						<p>align-content</p>
						<img src="img/align-content.svg" alt="">
<pre><code class="css" data-trim contenteditable>
.container {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}</code></pre>
						<aside class="notes">
							Met flex-wrap aan kan je ook bepalen wat er met de content tussen de regels gebeurt
						</aside>
					</section>
					<section>
						<h2>Properties for the Children</h2>
						<p>order</p>
						<img src="img/order.svg" alt="">
<pre><code class="css" data-trim contenteditable>
.item {
  order: &lt;integer>;
}</code></pre>
						<aside class="notes">
							Op welke plek moet dit ding staan. Superhandig voor responsive designs waar de volgorde van de code niet altijd overeenkomt met de ideale visuele volgorde.
						</aside>
					</section>
					<section>
						<h2>Properties for the Children</h2>
						<p>flex-grow</p>
						<img src="img/flex-grow.svg" alt="">
<pre><code class="css" data-trim contenteditable>
.item {
  flex-grow: &lt;number>; /* default 0 */
}</code></pre>
						<aside class="notes">
							Hoeveel ruimte moet dit ding innemen in verhouding tot de andere items? Als alles op 1 staat, dan is alles even breed. Als er echter eentje op 2 staat dan is die twee keer zo breed dan de andere items.
						</aside>
					</section>
					<section>
						<h2>Properties for the Children</h2>
						<p>flex-shrink</p>
<pre><code class="css" data-trim contenteditable>
.item {
  flex-shrink: &lt;number>; /* default 1 */
}</code></pre>
						<aside class="notes">
							Hoe moeten ze krimpen ten opzichte van elkaar? Als er echter eentje op 2 staat dan is die twee keer zo breed dan de andere items.
						</aside>
					</section>
					<section>
						<h2>Properties for the Children</h2>
						<p>flex-basis</p>
<pre><code class="css" data-trim contenteditable>
.item {
  flex-shrink: &lt;length> | auto; /* default auto */
}</code></pre>
						<aside class="notes">
							Dit is de voorkeursbreedte van een element. In combinatie met flex-wrap werkt het als een min-width
						</aside>
					</section>
					<section>
						<h2>Properties for the Children</h2>
						<p>align-self</p>
						<img src="img/align-self.svg" alt="">
<pre><code class="css" data-trim contenteditable>
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}</code></pre>
						<aside class="notes">
							Om één item anders uit te laten lijnen dan de standaard uitlijning.
						</aside>
					</section>
					<section>
						<h2>Flexbox in de praktijk</h2>
						<p><a href="http://philipwalton.github.io/solved-by-flexbox/">Mooie voorbeelden</a></p>
					</section>
				</section>

				<section>
					<section>
						<h1>Het Web Is Gek</h1>
					</section>
					<section>
						<h2>Het Web is er voor iedereen</h2>
						<aside class="notes">
							Een van de mooiste principes van het web is dat het er echt is voor iedereen. Iedereen met een computer en een browser moet gebruik kunnen maken van het web. TBL heeft daarom bewust ook geen patenten op zijn idee genomen. Het moet vrij, open en toegankelijk zijn voor iedereen. Hierdoor heeft het web wellicht een paar vreemde eigenschappen
						</aside>
					</section>
					<section>
						<h2>Iedereen heeft een muis</h2>
						<p class="fragment">behalve…</p>
						<aside class="notes">
							We ontwierpen website alleen voor de muis. Maar er zijn veel meer manieren om een site te bedienen. Vraag de klas om er een paar te benoemen. Denk aan muis, toetsenbord, dikke vingers, pennetjes, trackpads, game consoles, stem, oogbewegingen, gebaren in de lucht, etc. Alles moet met al deze dingen werken.
						</aside>
					</section>
					<section>
						<h2>Alle netwerkconnecties zijn goed</h2>
						<p class="fragment">behalve…</p>
						<aside class="notes">
							We gingen er altijd van uit dat internetconnecties elk jaar beter zouden worden. Maar iedereen die wel eens met de trein reist, of in een hotel zit weet dat dat niet zomaar klopt. Alles op het web moet dus ook werken met trage verbindingen. Er wordt ook wel gesproken over Offline First. Hier moet je rekening mee houden.
						</aside>
					</section>
					<section>
						<h2>COmputers worden steeds sneller</h2>
						<p class="fragment">behalve…</p>
						<aside class="notes">
							Computers werden steeds sneller. Totdat we ineens kleine computers in onze broekzak en tas stopten. Die moesten vooral een goede batterij hebben. Die dingen worden ook steeds sneller, maar tegelijkertijd is er een trend dat ze steeds goedkoper worden: de snelheid stagneert omdat andere dingen belangrijker zijn. Moore's Law gaat niet meer op!
						</aside>
					</section>
					<section>
						<h2>Alle beeldschermen zijn gekalibreerd</h2>
						<p class="fragment">behalve…</p>
						<aside class="notes">
							Eigenlijk bijna niet. Ze zijn allemaal crappy. Heel belangrijk om rekening mee te houden. Gaan we zeker mee aan de slag in het volgende blok.
						</aside>
					</section>
					<section>
						<h2>Alle schermen zijn even groot</h2>
						<p class="fragment">behalve…</p>
						<aside class="notes">
							Vroeger was het web 640px, daarna 800px, later 960px. Dat klopte nooit, maar dat wilden we: lekker makkelijk. Nu heeft het web elk mogelijk formaat. Alles wat we maken moet het op elk schermformaat doen. Daar gaan we vandaag iets dieper op in.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>Responsive Design</h1>

						<aside class="notes">
							In 2010 publiceerde Ethan Marcotte een artikel over responsive web design. De technieken die hij hierin beschrijft bestonden al langer, alleen gaf hij er een naam aan. Dat werkte. Sindsdien ontwerpt bijna iedereen sites die in principe op elk beeldscherm zouden moeten werken.
						</aside>
					</section>
					<section>
						<h2>Hoe deden we dat in het begin?</h2>

						<aside class="notes">
							Niet al te best, maar we moetsen ergens beginnen
						</aside>
					</section>
					<section data-background="img/content-7.jpg" data-background-size="contain">
						<aside class="notes">
							Stel dat we een site over een mooie oude auto zouden willen maken. Zo deden we dat tot voor kort.
						</aside>
					</section>
					<section data-background="img/content-1.png" data-background-size="contain">
						<aside class="notes">
							Elke website tot 2010 ontwierpen we door eerst een header toe te voegen
						</aside>
					</section>
					<section data-background="img/content-2.png" data-background-size="contain">
						<aside class="notes">
							Daarna een navigatie
						</aside>
					</section>
					<section data-background="img/content-3.png" data-background-size="contain">
						<aside class="notes">
							Widgets, waar die ook goed voor mogen zijn
						</aside>
					</section>
					<section data-background="img/content-4.png" data-background-size="contain">
						<aside class="notes">
							Een footer natuurlijk
						</aside>
					</section>
					<section data-background="img/content-5.png" data-background-size="contain">
						<aside class="notes">
							En daarna pas datgene waar het om gaat. De content vrotten we er als laatste nog even in. Dark ages.
						</aside>
					</section>
					<section data-background="img/content-6.jpg" data-background-size="contain">
						<aside class="notes">
							Terwijl dit toch juist is waar men voor kwam.
						</aside>
					</section>
					
					<section data-background="img/hard.jpg" data-background-size="contain">
						<aside class="notes">
							<p>Toen we gingen proberen om dit soort sites ook te laten werken op kleinere schermen merkten we dat dat echt heel erg moeilijk is. Veel, en veel te veel cruft. Het past gewoon niet. Het samenpersen van grote dingen tot iets kleiners kan, maar het is niet makkelijk. En of het nog echt functioneel is als je klaar bent is nog maar de vraag.</p>
						</aside>
					</section>
					<section data-background="img/amputeren.jpg" data-background-size="contain">
						<aside class="notes">
							Eerst probeerden we dit: content verbergen voor kleinere apparaten. "Mensen met mobiel hebben dit niet nodig", zeiden we. We deden allemaal aannames over mobiel, vooral dat mensen het alleen gebruiken als ze haast hebben, even snel, kort. Het tegenovergestelde blijkt waar. Content weg laten is dus niet zo'n goed idee. Vooral als iemand zeker weet dat bepaalde content wél beschikbaar was net op de desktop computer op het werk, en nu in de trein ineens niet meer. Frustrerend
						</aside>
					</section>
					<section data-background="img/growing.jpg" data-background-size="contain">
						<aside class="notes">
							Alles groeit. Babies, bomen, planten, dieren, kennis. Er moet wel iets voor gebeuren, maar niet zo heel erg veel. Het gaat bijna vanzelf. Itt krimpen. Alles wat in een klein scherm past past vanzelf ook in een groot scherm. Bovendien dwingt deze manier van werken je om goed na te denken over welke content er nu echt toe doet. Vroeger wilden we die prachtige white-space nog wel eens opvullen met domme ideeën, nu is daar gelukkig geen plek meer voor.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>Mobile first</h1>
						<aside class="notes">
							En zo werd Mobile First geboren
						</aside>
					</section>
					<section>
						<h1>Structured content first</h1>
						<aside class="notes">
							Eigenlijk gaat het niet over mobiel, maar het gaat over gestructureerde content. Daar moet je mee beginnen. 
						</aside>
					</section>
					<section data-background="img/groeien-2.png" data-background-size="contain">
						<aside class="notes">
							Ongestijlde maar gestructureerde content is misschien niet zo mooi, maar het werkt wel. Zeker op kleine schermen
						</aside>
					</section>
					<section data-background="img/groeien-3.png" data-background-size="contain">
						<aside class="notes">
							Met een beetje styling ziet het er zelfs best mooi uit.
						</aside>
					</section>
					<section data-background="img/groeien-4.png" data-background-size="contain">
						<aside class="notes">
							Op een breed scherm is het natuurlijk lelijk…
						</aside>
					</section>
					<section data-background="img/groeien-5.png" data-background-size="contain">
						<aside class="notes">
							Maar ook dat is eenvoudig op te lossen. VOlgens bepaalde designers is het nu af. Dit is een prima site. Hij werkt en hij is mooi.
						</aside>
					</section>
					<section data-background="img/groeien-6.png" data-background-size="contain">
						<aside class="notes">
							Maar je kan ook verder gaan en de boel optimaliseren voor grotere schermen. Extra layout toevoegen bijvoorbeeld. Of dingen in een rechter of linker kolom tonen. 
						</aside>
					</section>
					<section data-background="img/groeien-7.png" data-background-size="contain">
						<aside class="notes">
							Als laatste zou je er voor kunnen kiezen om nog extra verf toe te voegen. 
							Wellicht kan je hier een paar voorbeelden laten zien van briljante sites die op deze manier gemaakt zijn. Bijvoorbeeld het Rijksmuseum is er zo een — http://vvg.gr/gq — complete focus op de content, alle cruft is helemaal weg. Zelfs geen logo!
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Mediaqueries</h1>
						
						
						<aside class="notes">
							Layout veranderen voor verschillende schermresoluties doe je met mediaqueries. 
						</aside>
					</section>
					<section>
						<h2>Meta viewport</h2>
						
<pre><code class="HTML"><meta name="viewport" content="width=device-width, initial-scale=1">
</code></pre>
						<aside class="notes">
							Voordat we mediaqueries echt kunnen gebruiken moeten we deze regel code aan onze head toevoegen. Deze regel vertelt ons dat de browser op mobiele devices zo breed moet zijn als het apparaat zelf, en dat de zoom-factor gewoon op 1 moet staan. Als je deze regel niet toevoegd doen ook kleine schermen alsof ze 1120px breed zijn en zoomen vervolgens uit. Dat willen we voorkomen.
						</aside>
					</section>
					<section>
						<h2>Mediaquery</h2>
						
<pre><code class="css">body {
    max-width: 30em;
}
@media (min-width: 30em) {
	body {
	    max-width: 50em;
	}
}
</code></pre>
						<aside class="notes">
							Wat doet deze? Als het window breder is dan 30em (doet het er toe hoe breed dat is?) dan wordt de maximale breedte van de body 50em.
						</aside>
					</section>
					<section>
						<h2>Mediaquery</h2>
						
<pre><code class="css">body {
    padding: 5.5555vh 11.1111vw;
}
@media (min-aspect-ratio: 1/1) {
	body {
	    padding: 11.1111vh 11.1111vw;
	}
}
</code></pre>
						<aside class="notes">
							Wat doet deze? Als de browser een aspect ratio heeft die groter is dan 1/1 (het scherm is breder dan dat het hoog is) dan verandert de padding. Op de volgende slide staan nog een paar mediaqueries, een vragen of mensen er een paar kennen
						</aside>
					</section>
					<section>
						<h2>Mediaqueries</h2>
<pre><code data-trim contenteditable>
&lt;link media="(min-width: 50em)" rel="stylesheet" href="css.css">
</code></pre>
						
<pre><code class="css">@media (print) { … }
@media (orientation: landscape) { … }
@media (monochrome) { … }
@media (min-width: 70em), handheld and (orientation: landscape) { … }
</code></pre>
						<aside class="notes">
							Er zijn twee manieren om een mediaquert te gebruiken: in de link-tag in het media-attribuut, of in de CSS zelf. Die laatste scheelt een http-request en dat is waarschijnlijk beter: http-requests zijn een grotere aanslag op performance dan een paar kb.<br>
							Een komma betekent 'of'. In de laatste regel staat dus: de minimale breedte is 70em, OF het is een handheld apparaat waarvan de orientatie in landschapsmodus staat. Probeer dit soort complexe mediaqueries altijd te voorkomen. Er is waarschijnlijk iets mis met je ontwerp als je hierop uitkomt. Zijn er nog vragen?
						</aside>
					</section>
					
					
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>
<script src="slideshow.js"></script>
<script src="plugins/css-edit.js"></script>
<script src="plugins/css-snippets.js"></script>
<script src="plugins/css-controls.js"></script>
<script src="plugins/code-highlight.js"></script>
<script>
//var slideshow = new SlideShow();

var snippets = document.querySelectorAll('.snippet');
for(var i=0; i<snippets.length; i++) {
	new CSSSnippet(snippets[i]);
}

var cssControls = document.querySelectorAll('.css-control');
for(var i=0; i<cssControls.length; i++) {
	new CSSControl(cssControls[i]);
}
</script>
	</body>
</html>
